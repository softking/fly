很多人对这个黑科技有兴趣补充一个热更新说明


1、主进程第一次启动时 正常开启端口 例如：8080
2、当有新代码更新时，直接编译新的二进制文件，并且放在相同的目录下直接替换
3、向老进程发起 kill -HUB 命令  就是 kill -1 PID
4、老进程收到hub信号后 主动拉起新进程，并且把自己开启的端口、标准输入、输出等等一大坨的描述符全部组装成 启动参数。 假如8080端口的fd是 int  1，  就把 1 作为启动参数
5、新进程发现是被老进程拉起的就不在主动开启端口，而是通过启动参数里的 fd 直接复用现有的 socket fd
6、新进程准备就绪后会形成如下状态： 因为两个进程同时复用一个socket fd，所以当有新的连接过来后 系统会随机分配给两个都在等待 accept的进程
7、新进程就绪后向老进程发信号告知 已经就绪，老进程可以准备开始逐步退出了
8、老进程收到新进程的就绪信号后  会停止accept行为（这么做是为了让新来的连接全部都走到新的进程中accept，老进程不再处理新来的连接）
9、老进程把自己已经建立好的连接继续处理，直到处理完毕，然后安详的自杀
